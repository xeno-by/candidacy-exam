
\documentclass[hyperref={bookmarks=false}]{beamer}

\useoutertheme{infolines}
\setbeamertemplate{headline}{} % removes the headline that infolines inserts
% \setbeamertemplate{footline}{
%   \hfill%
%   \usebeamercolor[fg]{page number in head/foot}%
%   \usebeamerfont{page number in head/foot}%
%   \insertpagenumber\,/\,\insertpresentationendpage\kern1em\vskip2pt%
% }
\setbeamertemplate{footline}{
  \hfill%
  \usebeamercolor[fg]{page number in head/foot}%
  \usebeamerfont{page number in head/foot}%
  \insertpagenumber\kern1em\vskip2pt%
}
\setbeamertemplate{navigation symbols}{}

\usepackage[parfill]{parskip}
\usepackage{color}
\usepackage{listings}
\usepackage{textcomp}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{hyperref}
\usepackage{ulem}
\normalem
\hypersetup{pdfauthor={Eugene Burmako},pdfsubject={Metaprogramming with Macros},pdftitle={Metaprogramming with Macros}}
\title{Scala Macros}

\lstset{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{0.5,0.5,0.5},
  keywordstyle=\color{blue},
  commentstyle=\color{0,0.6,0},
  stringstyle=\color{0.58,0,0.82},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\setbeamercolor{alerted text}{fg=blue}
\setbeamerfont{alerted text}{series=\bfseries,family=\ttfamily}

\newmdenv[innerleftmargin=1mm, innerrightmargin=1mm, innertopmargin=-1mm, innerbottommargin=2mm, leftmargin=-1mm, rightmargin=-1mm]{lstlistinglike}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}

\title{Metaprogramming with Macros}
\author{Eugene Burmako}
\institute{\'Ecole Polytechnique F\'ed\'erale de Lausanne \\
           \texttt{http://scalamacros.org/}}
\date{10 September 2012}
{
\setbeamertemplate{footline}{}
\begin{frame}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
\frametitle{The essence of macros}
Macros are programmable code transformers
\end{frame}

\begin{frame}[fragile]
\frametitle{Example} % \only<1>

\begin{lstlistinglike}
\begin{semiverbatim}
(\alert{defmacro} let args
  (cons
   (cons 'lambda
         (cons (map car (car args))
               (cdr args)))
   (map cadr (car args))))
\end{semiverbatim}
\end{lstlistinglike}

Here we declare \emph{let}, a Lisp function. Since it is declared as a macro,
it's automatically plugged into the Lisp evaluator.

We can say that the evaluator installs a macro transformer implemented by the body of the macro
into a slot named \emph{let}.
\end{frame}

\begin{frame}[fragile]
\frametitle{Example} % \only<2>

\begin{lstlistinglike}
\begin{semiverbatim}
(defmacro \text{\color{blue}{let}} \text{\color{violet}{args}}
  (cons
   (cons 'lambda
         (cons (map car (car args))
               (cdr args)))
   (map cadr (car args))))

(\text{\color{blue}{let}} \text{\color{violet}{((x 40) (y 2)) (print (+ x y))}})
\end{semiverbatim}
\end{lstlistinglike}

When the evaluator encounters a form that is an application of \emph{let},
it yields control to the corresponding macro transformer,
passing it the tail of the form.
\end{frame}

\begin{frame}[fragile]
\frametitle{Example} % \only<3>

\begin{lstlistinglike}
\begin{semiverbatim}
(defmacro let args
  (cons
   (cons \text{\color{blue}{'lambda}}
         (cons \text{\color{red}{(map car (car args))}}
               \text{\color{violet}{(cdr args)}}))
   \text{\color{teal}{(map cadr (car args))}}))

\sout{(let ((\text{\color{red}{x}} \text{\color{teal}{40}}) (\text{\color{red}{y}} \text{\color{teal}{2}})) \text{\color{violet}{(print (+ x y))}})}

((\text{\color{blue}{lambda}} \text{\color{red}{(x y)}} \text{\color{violet}{(print (+ x y))}}) \text{\color{teal}{(40 2)}})
\end{semiverbatim}
\end{lstlistinglike}

The macro transformer takes the forms passed by the evaluator,
and computes a resulting form (this is called \emph{macro expansion}).

After that the evaluator proceeds with the form produced by macro expansion.
The value of the new form is returned as the value of the original form.
\end{frame}

\begin{frame}[fragile]
\frametitle{Use cases}

\begin{itemize}
\item Deeply embedded DSLs (database access, testing)
\item Optimization (programmable inlining, fusion)
\item Analysis (integrated proof-checker)
\item Effects (effect containment and propagation)
\end{itemize}

\vskip15pt

\only<2>{Actually these use cases come from our experience with macros in Scala,
which we developed this year.

All the aforementioned scenarios are either already supported by Scala macros
or will be supported in vNext!}
\end{frame}

\section{Challenges in macrology}

\begin{frame}[fragile]
\frametitle{Setting the stage}

In this talk we'll be looking into macros for compiled programming languages,
i.e. macros as extensions to compilers.

Different combinations of junction points (function applications, code annotations, custom grammar rules, etc)
and tightness of the integration (parser, namer, typer, etc) produce different challenges.

Today we're going to focus on a particular challenge in macrology: tackling syntactic abstractions.
These slides discuss the ways to represent, analyze and generate code.
\end{frame}

\begin{frame}[fragile]
\frametitle{Revisiting \emph{let}}

\begin{lstlistinglike}
\begin{semiverbatim}
(defmacro let args
\only<1>{\
 (cons
   (cons \text{\color{blue}{'lambda}}
         (cons \text{\color{red}{(map car (car args))}}
               \text{\color{violet}{(cdr args)}}))
   \text{\color{teal}{(map cadr (car args))}}))}\
\only<2>{\
`(('\text{\color{blue}{lambda}} ,\text{\color{red}{(map car decls)}} ,\text{\color{violet}{body}}) . ,\text{\color{teal}{(map cadr decls)}}))
}
\sout{(let ((\text{\color{red}{x}} \text{\color{teal}{40}}) (\text{\color{red}{y}} \text{\color{teal}{2}})) \text{\color{violet}{(print (+ x y))}})}

((\text{\color{blue}{lambda}} \text{\color{red}{(x y)}} \text{\color{violet}{(print (+ x y))}}) \text{\color{teal}{(40 2)}})
\end{semiverbatim}
\end{lstlistinglike}

\only<1>{The code here is quite impenetrable.
Without color coding it would be hard to understand the supposed structure of input and output.}

\only<2>{}
\end{frame}

\section{Macros in Template Haskell}

\section{Macros in Nemerle}

\section{Macros in Racket}

\section{Macros in Scala}

\section{Future work}

\end{document}