\documentclass[hyperref={bookmarks=false}]{beamer}
\useoutertheme{infolines}
\setbeamertemplate{headline}{} % removes the headline that infolines inserts
% \setbeamertemplate{footline}{
%   \hfill%
%   \usebeamercolor[fg]{page number in head/foot}%
%   \usebeamerfont{page number in head/foot}%
%   \insertpagenumber\,/\,\insertpresentationendpage\kern1em\vskip2pt%
% }
\setbeamertemplate{footline}{
  \hfill%
  \usebeamercolor[fg]{page number in head/foot}%
  \usebeamerfont{page number in head/foot}%
  \insertpagenumber\kern1em\vskip2pt%
}
\setbeamertemplate{navigation symbols}{}
\setbeamercolor{alerted text}{fg=blue}
\setbeamerfont{alerted text}{series=\bfseries,family=\ttfamily}
\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}
\usepackage[parfill]{parskip}
\usepackage{color}
\usepackage[linewidth=0.5pt]{mdframed}
\newmdenv[innerleftmargin=1mm, innerrightmargin=1mm, innertopmargin=-1mm, innerbottommargin=2mm, leftmargin=-1mm, rightmargin=-1mm]{lstlistinglike}
\usepackage{tikz}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{textcomp}

\hypersetup{pdfauthor={Eugene Burmako},pdfsubject={Metaprogramming with Macros},pdftitle={Metaprogramming with Macros}}
\title{Scala Macros}

\begin{document}

\title{Metaprogramming with Macros}
\author{Eugene Burmako}
\institute{\'Ecole Polytechnique F\'ed\'erale de Lausanne \\
           \texttt{http://scalamacros.org/}}
\date{10 September 2012}
{
\setbeamertemplate{footline}{}
\begin{frame}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
\frametitle{What are macros?}
Macros in programming languages:
\begin{itemize}
\item C macros
\item Lisp macros
\item ...
\end{itemize}

\vskip25pt
What is the underlying concept?
\vskip25pt
\pause

Macros realize the notion of textual abstraction:
\begin{itemize}
\item Recognize pieces of text that match a specification
\item Replace them according to a procedure
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Why macros?}

Work with syntax trees, therefore are not bound by the semantics of the underlying
programming language

Use cases:
\begin{itemize}
\item Deeply embedded DSLs (database access, testing)
\item Optimization (programmable inlining, fusion)
\item Analysis (integrated proof-checker)
\item Effects (effect containment and propagation)
\item ...
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Macrology}
\begin{itemize}
\item Notation
\item \text{\color{blue}{Bindings}}
\item Typechecking
\item Syntax extensibility
\item ...
\end{itemize}
\end{frame}

% \begin{frame}[fragile]
% \frametitle{Alexandre Dumas}

% \begin{center}
% \includegraphics[width=5.5cm]{dumas}
% \end{center}
% \end{frame}

\section{The prelude of macros}

\begin{frame}[fragile]
\frametitle{A detour: how Lisp works}
\begin{semiverbatim}
(if (calculate)
  (print "success")
  (error "does not compute"))
\end{semiverbatim}

\vskip50pt

\begin{itemize}
\item S-expressions: atoms and lists
\item \texttt{print} and \texttt{error} are one-argument functions
\item \texttt{calculate} is a zero-argument function
\item \texttt{if} is a special form
\item All values can be used in conditions
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Anaphoric \texttt{if}}
\frametitle<2>{The \texttt{aif} macro}
\frametitle<3>{Low-level implementation}
\frametitle<4>{Quasiquoting: static template}
\frametitle<5>{Quasiquoting: dynamic holes}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

\visible<2->{(defmacro aif args}
  \visible<3->{\only<3>{(list 'let* (list (list 'temp (car args))}}\only<4->{\alert{`}(let* ((temp \only<4>{...........)}\only<5->{\alert{,(car args)})}}
          \visible<3->{\only<3>{          (list 'it 'temp))}\only<4->{(it temp))}}
     \visible<3->{\only<3>{(list 'if 'temp}\only<4->{(if temp}}
       \visible<3->{\only<3>{(cadr args)}\only<4>{............}\only<5->{\alert{,(cadr args)}}}
       \visible<3->{\only<3>{(caddr args)))}\only<4>{............}\only<5->{\alert{,(caddr args)}})}

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Macro by example (MBE)}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro+ aif
  \alert{(aif cond then else)}
  (let* ((temp \alert{cond})
         (it temp))
    (if temp
        \alert{then}
        \alert{else})))

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interlude}

\begin{semiverbatim}
(defmacro+ aif
  (aif cond then else)
  (let* ((temp cond)
         (it temp))
    (if temp then else)))
\end{semiverbatim}

\vskip50pt

\begin{itemize}
\item Macros are functions that transform syntax objects
\item Quasiquotes = static templates + dynamic holes
\item Impressive power for minimal investments from the compiler
\end{itemize}
\end{frame}

\section{The chapter of bindings}

\begin{frame}[fragile]
\frametitle{The \texttt{aif} macro is buggy}
\begin{semiverbatim}
\text{\color{blue}{(aif (calculate)}}
  \text{\color{blue}{(print it)}}
  \text{\color{blue}{(error "does not compute"))}}

(defmacro+ aif
  (aif cond then else)
  \text{\color{red}{(let* ((temp cond)}}
         \text{\color{red}{(it temp))}}
    \text{\color{red}{(if temp then else))}})

\visible<2>{\text{\color{red}{(let* ((temp \text{\color{blue}{(calculate)}})}}}
       \visible<2>{\text{\color{red}{(it temp))}}}
  \visible<2>{\text{\color{red}{(if temp}}}
    \visible<2>{\text{\color{blue}{(print it)}}}
    \visible<2>{\text{\color{blue}{(error "does not compute")}}\text{\color{red}{))}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Bug \#1: Violation of hygiene}
\begin{semiverbatim}
(let ((\text{\color{blue}{temp}} 451{\textdegree}F))
  (aif (calculate)
    (print it)
    (print \text{\color{blue}{temp}})))

(defmacro+ aif
  (aif cond then else)
  (let* ((\text{\color{red}{temp}} cond)
         (it temp))
    (if temp then \text{\color{red}{else}})))

(let ((\text{\color{blue}{temp}} 451{\textdegree}F))
  (let* ((\text{\color{red}{temp}} (calculate))
         (it temp))
    (if temp
      (print it)
      (print \text{\color{red}{temp}}))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Bug \#2: Violation of referential transparency}
\begin{semiverbatim}
(let ((\text{\color{blue}{if hijacked}}))
  (aif (calculate)
    (print it)
    (error "does not compute")))

(defmacro+ aif
  (aif cond then else)
  (let* ((temp cond)
         (it temp))
    (\text{\color{red}{if}} temp then else))) \text{\color{red}{;; core if}}

(let ((\text{\color{blue}{if hijacked}}))
  (let* ((temp (calculate))
         (it temp))
    (\text{\color{blue}{if}} temp \text{\color{blue}{;; hijacked if}}
      (print it)
      (error "does not compute"))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Old school solution}
\begin{semiverbatim}
(defmacro+ aif
  (aif cond then else)
  \alert{(let ((temp (gensym)))}
    (let* ((temp cond)
           (it temp))
      (if temp then else))))
\end{semiverbatim}

\text{\color{blue}{And please don't rename core forms}}
\end{frame}

\section{The trilogy of tongues}

\begin{frame}[fragile]
\frametitle{Three macro-enabled languages}

\emph{Template Meta-programming for Haskell} \text{\color{blue}{[Template Haskell]}}\\
by Tim Sheard and Simon Peyton Jones

\vskip15pt

\emph{Meta-programming in Nemerle} \text{\color{blue}{[Nemerle]}}\\
by Kamil Skalski, Michal Moskal and Pawel Olszta.

\vskip15pt

\emph{Keeping it Clean with Syntax Parameters} \text{\color{blue}{[Racket]}}\\
by Eli Barzilay, Ryan Culpepper and Matthew Flatt

\vskip15pt

All three languages:
\begin{itemize}
\item Solve the problems of hygiene and referential transparency
\item Do this in their own interesting ways
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Template Haskell: Introduction}
\frametitle<2>{Template Haskell: The perils of hygiene}
\begin{semiverbatim}
{\textdollar}(aif [| calculate |]
  [| putStrLn (show \text{\color<2->{blue}{it}}) |]
  [| error "does not compute" |])

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond then' else' =
  [| let temp = {\textdollar}cond
         \text{\color<2->{red}{it}} = temp
     in if temp /= 0 then {\textdollar}then' else {\textdollar}else' |]
\only<2->{
let temp_a1mx = calculate
    \text{\color{red}{it_a1my}} = temp_a1mx
in if (temp_a1mx /= 0)
   then putStrLn (show \text{\color{blue}{it}})
   else error "does not compute"

\text{\color{blue}{Not in scope: `it'}}}
\end{semiverbatim}

\only<1>{
\begin{itemize}
\item No dedicated concept of macros
\item Macro expansions are triggered explicitly with \texttt{\textdollar}
\item There are quasiquotes \texttt{[| ...\ |]} and unquotes \texttt{{\textdollar}expr}
\item Hygienic and referentially transparent
\end{itemize}
\vskip14pt
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Template Haskell: The \texttt{Q} monad}
\begin{semiverbatim}
aif cond then' else' =
  [| let \text{\color{blue}{temp = {\textdollar}cond}}
         \text{\color{blue}{it = temp}}
     in if temp \text{\color{red}{/=}} 0 then {\textdollar}then' else {\textdollar}else' |]

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond' then'' else'' =
    do \{ ...
       ; \text{\color{blue}{temp <- newName "temp"}}
       ; \text{\color{blue}{it <- newName "it"}}
       ; \text{\color{red}{let notEq = mkNameG_v "ghc-prim" "GHC.Classes" "/="}}
         in return (LetE ... (CondE (... then' else')) ...)
       \}
\end{semiverbatim}
          % (LetE [ValD (VarP temp) (NormalB cond) [],
          %        ValD (VarP it) (NormalB (VarE temp)) []]
          %       (CondE (... (VarE notEq) ...) then' else'))
          %       (CondE (InfixE (Just (VarE temp)) (VarE notEq) (Just (LitE (IntegerL 0)))) then' else'))
\end{frame}

\begin{frame}[fragile]
\frametitle{Template Haskell: Breaking hygiene}
\begin{semiverbatim}
{\textdollar}(aif [| calculate |]
  [| putStrLn (show \alert{{\textdollar}(dyn "it")}) |]
  [| error "does not compute" |])

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond then' else' =
  [| let temp = {\textdollar}cond
         \text{\color{red}{it}} = temp
     in if temp /= 0 then {\textdollar}then' else {\textdollar}else' |]

let temp_a1mx = calculate
    \text{\color{red}{it_a1my}} = temp_a1mx
in if (temp_a1mx /= 0)
   then putStrLn (show \text{\color{blue}{it_a1my}})
   else error "does not compute"
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Template Haskell: Summary}
\begin{itemize}
\item Template Haskell is auto hygienic and referentially transparent
\item The Q monad takes care of names
\item Sometimes we need to break hygiene
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Nemerle: Introduction}
\frametitle<2>{Nemerle: The perils of hygiene}
\begin{semiverbatim}
aif(calculate,
  WriteLine(\text{\color<2->{blue}{it}}),
  throw Exception("does not compute"))

macro aif(cond, then, else_) \{
  <[
    def temp = {\textdollar}cond;
    def \text{\color<2->{red}{it}} = temp;
    if (temp != 0) {\textdollar}then else {\textdollar}else_
  ]>
\}
\only<2>{
def calculate = 42;
def temp_1087 = calculate;
def \text{\color{red}{it_1088}} = temp_1087;
if (temp_1087 != 0) WriteLine(\text{\color{blue}{it}}) else throw Exception("...")

\text{\color{blue}{error: unbound name `it'}}}
\end{semiverbatim}

\only<1>{
\begin{itemize}
\item Macros are declared explicitly, expansions are implicit
\item There are quasiquotes \texttt{<[ ...\ ]>} and unquotes \texttt{{\textdollar}expr}
\item Hygienic and referentially transparent
\end{itemize}
\vskip14pt
}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Nemerle: Coloring algorithm}
\frametitle<2>{Nemerle: Coloring algorithm}%: normal code gets a vanilla color}
\frametitle<3>{Nemerle: Coloring algorithm}%: each expansion gets unique colors}
\frametitle<4>{Nemerle: Coloring algorithm}%: at the end of the day}
\frametitle<5>{Nemerle: Breaking hygiene}%: inherit use site}
\begin{semiverbatim}
def \text{\color<2-4>{blue}{calculate}} = 42;                 \only<2->{\text{\color{blue}{// vanilla color}}}
aif(\text{\color<2-4>{blue}{calculate}},
  WriteLine(\text{\color<2-5>{blue}{it}}),
  throw Exception("does not compute"))

macro aif(cond, then, else_) \{      \only<3->{\text{\color{red}{// expansion color}}}
  <[
    def \text{\color<3-4>{red}{temp}} = \text{\color<3-4>{blue}{{\textdollar}cond}};
    def \only<1,2>{it}\only<3,4>{\text{\color{red}{it}}}\only<5>{\text{\color{blue}{{\textdollar}("it": usesite)}}} = \text{\color<3-4>{red}{temp}};    \only<5->{\text{\color{blue}{// recolor the variable}}}
    if (\text{\color<3-4>{red}{temp}} != 0) \text{\color<3-4>{blue}{{\textdollar}then}} else \text{\color<3-4>{blue}{{\textdollar}else_}}
  ]>
\}

def \text{\color<4-4>{blue}{calculate}} = 42;                 \only<4->{// bind using colors}
def \text{\color<4-4>{red}{temp}} = \text{\color<4-4>{blue}{calculate}};
def \text{\color<4>{red}{\color<5>{blue}{it}}} = \text{\color<4-4>{red}{temp}};
if (\text{\color<4-4>{red}{temp}} != 0) WriteLine(\text{\color<4->{blue}{it}}) else throw Exception("...")
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Nemerle: Summary}
\begin{itemize}
\item Nemerle takes care of hygiene with a coloring algorithm
\item No complex translation algorithms are necessary
\item As another bonus programmer can fine-tune colors with \texttt{MacroColors}
\item Referential transparency works as well
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Racket: Introduction}
\frametitle<2>{Racket: The perils of hygiene}
\frametitle<3>{Racket: Breaking hygiene}
\begin{semiverbatim}
\text{\color<2->{blue}{(aif (calculate)}}
  \text{\color<2->{blue}{(print it)}}
  \text{\color<2->{blue}{(error "does not compute"))}}

(define-syntax (aif stx)
  (syntax-case stx ()
    ((aif cond then else)
     \visible<3->{(with-syntax ((\text{\color<3->{blue}{it}} (datum->syntax \text{\color<3->{blue}{#'aif}} \text{\color<3->{red}{'it}})))}
       #'(let ((temp cond)
               (\text{\color<3->{blue}{\color<2>{red}{it}}} temp)))
           (if temp then else)))))\visible<3->{)}
\only<2->{
(let* ((temp (calculate))
       (\text{\color<3->{blue}{\color<2>{red}{it}}} temp))
  (if temp
    \text{\color<2->{blue}{(print it)}}
    \text{\color<2->{blue}{(error "does not compute")}}))}
\end{semiverbatim}

\only<1>{
\begin{itemize}
\item A Lisp, descendent from Scheme
\item 25 years of hygienic macros, a bunch of macro systems
\item Language features written using macros (classes, modules, etc)
\end{itemize}
\vskip7pt
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Racket: Hacks don't scale}
\begin{semiverbatim}
\text{\color<3->{teal}{(aunless (not (calculate))}}
  \text{\color<3->{teal}{(print it)}}
  \text{\color<3->{teal}{(error "does not compute"))}}

(define-syntax (aunless stx)
  (syntax-case stx ()
    (\alert<1>{(aunless cond then else)}
     \text{\color<2->{blue}{\alert<1>{#'(aif (not cond) then else)}}})))

\text{\color<2->{red}{(let* ((temp (not (not (calculate))))}}
       \text{\color<2->{red}{(}}\text{\color<2->{blue}{it}} \text{\color<2->{red}{temp))}}
  \text{\color<2->{red}{(if temp}}
    \text{\color<3->{teal}{(print it)}}
    \text{\color<3->{teal}{(error "does not compute")}}))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Racket: Syntax parameters}
\begin{semiverbatim}

\text{\color{teal}{(define-syntax-parameter it (syntax-rules ()))}}

(define-syntax (aif stx)
  (syntax-case stx ()
    ((aif cond then else)
     #'(let ((temp cond))
             \text{\color{teal}{(syntax-parameterize}}
               \text{\color{teal}{((it (syntax-rules () ((_) temp))))}}
         (if temp then else))))))

\end{semiverbatim}

\begin{itemize}
\item \texttt{it} becomes a compile-time dynamic variable
\item Therefore its scope overarches all potential expansions
\item High-level language feature (dynamic variables) + macros = win
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: overall}
\begin{itemize}
\item There are algorithms that take care of hygiene and referential transparency
\item These algorithms can work in automatic mode, but are flexible enough to give the programmer full control
\item Like a silver bullet
\item Nevertheless sometimes even better solutions come from integration with language features
\end{itemize}
\end{frame}

\section{The vision of the days to come}

\begin{frame}[fragile]
\frametitle{scalamacros.org}
\begin{itemize}
\item Since this semester Scala has macros
\item Even better: macros are an official part of the language in the next production release 2.10.0
\item Now it's time to put the pens down and think about the future
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implicits}
\begin{semiverbatim}
\visible<2->{trait Serializer[T] \{
  def write(pickle: Pickle, x: T): Unit
\}
}
def serialize[T](x: T)\only<2->{(\only<3->{\alert<3>{implicit }}s: Serializer[T])}: Pickle

\visible<3->{\only<1-3>{\alert<3>{implicit object ByteSerializer extends Serializer[Byte] \{
  def write(pickle: Pickle, x: Byte) = pickle.writeByte(x)
\}}}\only<4->{\visible<4->{\alert<4>{implicit def generator: Serializer[T] = macro impl[T]

}}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Research proposal}

Marry macros and high-level language features:

\begin{itemize}
\item Macros + functions $\rightarrow$ programmable inlining, specialization, fusion
\item Macros + annotations $\rightarrow$ code contracts
\item Macros + path-dependent types $\rightarrow$ controlled effects
\item Macros + implicits $\rightarrow$ static verification
\item ...
\end{itemize}
\end{frame}

\end{document}