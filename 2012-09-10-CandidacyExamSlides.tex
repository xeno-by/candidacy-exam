\documentclass[hyperref={bookmarks=false}]{beamer}
\useoutertheme{infolines}
\setbeamertemplate{headline}{} % removes the headline that infolines inserts
% \setbeamertemplate{footline}{
%   \hfill%
%   \usebeamercolor[fg]{page number in head/foot}%
%   \usebeamerfont{page number in head/foot}%
%   \insertpagenumber\,/\,\insertpresentationendpage\kern1em\vskip2pt%
% }
\setbeamertemplate{footline}{
  \hfill%
  \usebeamercolor[fg]{page number in head/foot}%
  \usebeamerfont{page number in head/foot}%
  \insertpagenumber\kern1em\vskip2pt%
}
\setbeamertemplate{navigation symbols}{}
\setbeamercolor{alerted text}{fg=blue}
\setbeamerfont{alerted text}{series=\bfseries,family=\ttfamily}
\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}
\usepackage[parfill]{parskip}
\usepackage{color}
\usepackage[linewidth=0.5pt]{mdframed}
\newmdenv[innerleftmargin=1mm, innerrightmargin=1mm, innertopmargin=-1mm, innerbottommargin=2mm, leftmargin=-1mm, rightmargin=-1mm]{lstlistinglike}
\usepackage{tikz}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{textcomp}

\hypersetup{pdfauthor={Eugene Burmako},pdfsubject={Metaprogramming with Macros},pdftitle={Metaprogramming with Macros}}
\title{Scala Macros}

\begin{document}

\title{Metaprogramming with Macros}
\author{Eugene Burmako}
\institute{\'Ecole Polytechnique F\'ed\'erale de Lausanne \\
           \texttt{http://scalamacros.org/}}
\date{10 September 2012}
{
\setbeamertemplate{footline}{}
\begin{frame}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
\frametitle{Macros}
\pause
Macros realize the notion of textual abstraction.

Textual abstraction:
\begin{itemize}
\item Recognize pieces of text that match a specification
\item Replace them according to a procedure
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
\begin{semiverbatim}
(let (x 42) (print x))







\pause
((lambda (x) (print x)) 42)
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Step 1. Recognize pieces of text}
\begin{semiverbatim}
(\text{\color{blue}{let}} \text{\color{red}{(x 42) (print x))}}

(defmacro \text{\color{blue}{let}} \text{\color{red}{args}}






((lambda (x) (print x)) 42)
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Step 2. Replace them according to a procedure}
\begin{semiverbatim}
(let (\text{\color{red}{x}} \text{\color{teal}{42}}) \text{\color{violet}{(print x)}})

(defmacro let args
  (cons
   (cons \text{\color{blue}{'lambda}}
         (cons (list \text{\color{red}{(caar args)}})
               \text{\color{violet}{(cdr args)}}))
   \text{\color{teal}{(cdar args)}}))

((\text{\color{blue}{lambda}} (\text{\color{red}{x}}) \text{\color{violet}{(print x)}}) \text{\color{teal}{42}})
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{The essence of macros}
\begin{itemize}
\item Recognize pieces of text that match a specification
\item Replace them according to a procedure
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Why macros?}
\begin{itemize}
\item Deeply embedded DSLs (database access, testing)
\item Optimization (programmable inlining, fusion)
\item Analysis (integrated proof-checker)
\item Effects (effect containment and propagation)
\item ...
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Today's talk}

Macrology is vast:
\begin{itemize}
\item Notation
\item Variable capture
\item Typechecking meta-programs
\item Syntax extensibility
\item ...
\end{itemize}

Surveyed papers are versatile as well.
\end{frame}

\begin{frame}[fragile]
\frametitle{Today's talk}

Going into all the details would be a genuine pleasure.
% and I would invite you to share this pleasure with me during the second part of the oral exam.

But instead let me tell you a story.
\end{frame}

% \begin{frame}[fragile]
% \frametitle{Alexandre Dumas}

% \begin{center}
% \includegraphics[width=5.5cm]{dumas}
% \end{center}
% \end{frame}

\section{The prelude of macros}

\begin{frame}[fragile]
\frametitle<1>{Anaphoric \texttt{if}}
\frametitle<2>{Anaphoric \texttt{if}}
\frametitle<3>{The \texttt{aif} macro}
\frametitle<4->{Start with a notation}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

\visible<3->{(defmacro aif args}
        \visible<4->{(let*            ((temp  (car args))}
        \visible<4->{                  (it  temp))}
          \visible<4->{(if  temp}
             \visible<4->{(cadr args)}
             \visible<4->{(caddr args))))}

\visible<2->{(let* ((temp (calculate))}
       \visible<2->{(it temp))}
  \visible<2->{(if temp}
    \visible<2->{(print it)}
    \visible<2->{(error "does not compute")))}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Surround it with parentheses}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro aif args
  \alert{(list '}let* \alert{(list (list '}temp  (car args))
  \alert{                  (list '}it \alert{'}temp\alert{))}
    \alert{(list '}if \alert{'}temp
             (cadr args)
             (caddr args)\alert{))})

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Quasiquote}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro aif args
  \visible<2->{\alert{     `}}(let*            ((temp  ..........)
                          (it  temp))
          (if  temp
             ............
             ............)))

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Unquote}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro aif args
  \alert{     `}(let*            ((temp \alert{,(car args)})
                          (it  temp))
          (if  temp
            \alert{,(cadr args)}
            \alert{,(caddr args)})))

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Unquote}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro  aif args

 `(let* ((temp ,(car args))
         (it temp))
    (if temp
        ,(cadr args)
        ,(caddr args))))

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Macro by example (MBE)}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro+ aif
  \alert{(aif cond then else)}
  (let* ((temp \alert{cond})
         (it temp))
    (if temp
        \alert{then}
        \alert{else})))

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interlude}
\begin{itemize}
\item Macros are regular functions that happen to work with syntax objects
\item Quasiquotes = static templates + dynamic holes
\end{itemize}
\end{frame}

\section{The tale of bindings}

\begin{frame}[fragile]
\frametitle{Anaphoric \texttt{if}}
\begin{semiverbatim}
(defmacro+ aif
  (aif cond then else)
  (let* ((temp cond)
         (it temp))
    (if temp then else)))
\end{semiverbatim}

\begin{itemize}
\item So far macros are simple: define a function, recognize pieces of text and replace them with a template
\item This is so immediately useful, that we could wrap up right now
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{But actually}
The \texttt{aif} macro has two bugs
\end{frame}

\begin{frame}[fragile]
\frametitle{What's wrong?}
\begin{semiverbatim}
\visible<2->{\text{\color<3->{blue}{(aif (calculate)}}}
\visible<2->{  \text{\color<3->{blue}{(print it)}}}
  \visible<2->{\text{\color<3->{blue}{(error "does not compute"))}}}

(defmacro+ aif
  (aif cond then else)
  \text{\color<3->{red}{(let* ((temp cond)}}
         \text{\color<3->{red}{(it temp))}}
    \text{\color<3->{red}{(if temp then else))}})

\visible<4->{\text{\color<4->{red}{(let* ((temp \text{\color<4->{blue}{(calculate)}})}}}
       \visible<4->{\text{\color<4->{red}{(it temp))}}}
  \visible<4->{\text{\color<4->{red}{(if temp}}}
    \visible<4->{\text{\color<4->{blue}{(print it)}}}
    \visible<4->{\text{\color<4->{blue}{(error "does not compute")}}\text{\color<4->{red}{))}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Bug \#1: Violation of hygiene}
\begin{semiverbatim}
(let ((\text{\color{blue}{temp}} 451{\textdegree}F))
  (aif (calculate)
    (print it)
    (print \text{\color{blue}{temp}})))

(defmacro+ aif
  (aif cond then else)
  (let* ((\text{\color{red}{temp}} cond)
         (it temp))
    (if temp then \text{\color{red}{else}})))

(let ((\text{\color{blue}{temp}} 451{\textdegree}F))
  (let* ((\text{\color{red}{temp}} (calculate))
         (it temp))
    (if temp
      (print it)
      (print \text{\color{red}{temp}}))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Bug \#2: Violation of referential transparency}
\begin{semiverbatim}
(let ((\text{\color{blue}{if}} hijacked))
  (aif (calculate)
    (print it)
    (error "does not compute")))

(defmacro+ aif
  (aif cond then else)
  (let* ((temp cond)
         (it temp))
    (\text{\color{red}{if}} temp then else)))

(let ((\text{\color{blue}{if}} hijacked))
  (let* ((temp (calculate))
         (it temp))
    (\text{\color{blue}{if}} temp
      (print it)
      (error "does not compute"))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Old school}
\begin{semiverbatim}
(defmacro+ aif
  (aif cond then else)
  \visible<2>{\alert{(let ((temp (gensym)))}}
    (let* ((temp cond)
           (it temp))
      (if temp then else)))\visible<2>{\alert{)}}
\end{semiverbatim}

\visible<2>{And please don't rename core forms}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interlude}
\begin{itemize}
\item Cross-pollination of scopes can lead to inadvertent variable capture
\item Violation of hygiene = def site harms call site
\item Violation of referential transparency = call site harms def site
\end{itemize}
\end{frame}

\section{The trilogy of tongues}

\begin{frame}[fragile]
\frametitle{Template Haskell}
\begin{semiverbatim}
\visible<2->{{\textdollar}(aif [| calculate |]}
  \visible<2->{[| putStrLn (show \text{\color<3->{blue}{it}}) |]}
  \visible<2->{[| error "does not compute" |])}

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond then' else' =
  [| let temp = {\textdollar}cond
         \text{\color<3->{red}{it}} = temp
     in if temp /= 0 then {\textdollar}then' else {\textdollar}else' |]

\visible<3->{let temp_a1mx = calculate}
    \visible<3->{\text{\color{red}{it_a1my}} = temp_a1mx}
\visible<3->{in if (temp_a1mx /= 0)}
   \visible<3->{then putStrLn (show \text{\color{blue}{it}})}
   \visible<3->{else error "does not compute"}

\visible<3->{\text{\color{red}{Not in scope: `it'}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{The \texttt{Q} monad}
\begin{semiverbatim}
aif cond then' else' =
  [| let \text{\color<2->{blue}{temp = {\textdollar}cond}}
         \text{\color<2->{blue}{it = temp}}
     in if temp \text{\color<2->{red}{/=}} 0 then {\textdollar}then' else {\textdollar}else' |]

\visible<2>{aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp}
\visible<2>{aif cond' then'' else'' =}
    \visible<2>{do \{ \text{\color{blue}{temp <- newName "temp"}}}
       \visible<2>{; \text{\color{blue}{it <- newName "it"}}}
       \visible<2>{; cond <- cond'}
       \visible<2>{; then' <- then''}
       \visible<2>{; else' <- else''}
       \visible<2>{; \text{\color{red}{let notEq = mkNameG_v "ghc-prim" "GHC.Classes" "/="}}}
         \visible<2>{in return}
          \visible<2>{(LetE [ValD (VarP temp) (NormalB cond) [],}
                 \visible<2>{ValD (VarP it) (NormalB (VarE temp)) []]}
                \visible<2>{(CondE (... (VarE notEq) ...) then' else'))}
       \visible<2>{\}}

\end{semiverbatim}
                % (CondE (InfixE (Just (VarE temp)) (VarE notEq) (Just (LitE (IntegerL 0)))) then' else'))
\end{frame}

\begin{frame}[fragile]
\frametitle{Perils of hygiene}
\begin{semiverbatim}
{\textdollar}(aif [| calculate |]
  [| putStrLn (show \alert{{\textdollar}(dyn "it")}) |]
  [| error "does not compute" |])

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond then' else' =
  [| let temp = {\textdollar}cond
         it = temp
     in if temp /= 0 then {\textdollar}then' else {\textdollar}else' |]
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: Template Haskell}
\begin{itemize}
\item Quasiquotes in Template Haskell are automatically hygienic and referentially transparent
\item That's because are translated into Q monad, which takes care of \texttt{gensym}ming and fully qualified names
\item When hygiene fails, we are forced to drop to low level
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Nemerle}
\begin{semiverbatim}
\visible<2->{aif(calculate,}
  \visible<2->{WriteLine(\text{\color<3->{blue}{it}}),}
  \visible<2->{throw Exception("does not compute"))}

macro aif(cond, then, else_) \{
  <[
    def temp = {\textdollar}cond;
    def \text{\color<3->{red}{it}} = temp;
    if (temp != 0) {\textdollar}then else {\textdollar}else_
  ]>
\}

\visible<3->{def calculate = 42;}
\visible<3->{def temp_1087 = calculate;}
\visible<3->{def \text{\color{red}{it_1088}} = temp_1087;}
\visible<3->{if (temp_1087 != 0) WriteLine(\text{\color{blue}{it}}) else throw Exception("...")}

\visible<3->{\text{\color{red}{error: unbound name `it'}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Coloring algorithm}
\frametitle<2>{Coloring algorithm: normal code gets a vanilla color}
\frametitle<3>{Coloring algorithm: each expansion gets unique colors}
\frametitle<4>{Coloring algorithm: at the end of the day}
\frametitle<5>{Coloring algorithm: inherit use site}
\frametitle<6>{Coloring algorithm: polychromatic}
\begin{semiverbatim}
def \text{\color<2-4>{blue}{calculate}} = 42;                 \only<2->{\text{\color{blue}{// vanilla color}}}
aif(\text{\color<2-4>{blue}{calculate}},
  WriteLine(\text{\color<2-4>{blue}{it}}),
  throw Exception("does not compute"))

macro aif(cond, then, else_) \{      \only<3->{\text{\color{red}{// expansion color}}}
  <[
    def \text{\color<3-4>{red}{temp}} = \text{\color<3-4>{blue}{{\textdollar}cond}};
    def \only<1,2>{it}\only<3,4>{\text{\color{red}{it}}}\only<5>{\text{\color{blue}{{\textdollar}("it": usesite)}}}\only<6>{\text{\color{blue}{{\textdollar}}\color{red}{(}\color{blue}{"}\color{red}{i}\color{blue}{t}"\color{blue}{:} \color{red}{d}\color{blue}{y}\color{red}{n}\color{blue}{)}}} = \text{\color<3-4>{red}{temp}};
    if (\text{\color<3-4>{red}{temp}} != 0) \text{\color<3-4>{blue}{{\textdollar}then}} else \text{\color<3-4>{blue}{{\textdollar}else_}}
  ]>
\}

def \text{\color<4-4>{blue}{calculate}} = 42;                 \only<4->{// bind using colors}
def \text{\color<4-4>{red}{temp}} = \text{\color<4-4>{blue}{calculate}};
def \text{\color<4>{red}{\color<5>{blue}{\color<6>{red}{i}\color<6>{blue}{t}}}} = \text{\color<4-4>{red}{temp}};
if (\text{\color<4-4>{red}{temp}} != 0) WriteLine(\text{\color<4->{blue}{it}}) else throw Exception("...")
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: Nemerle}
\begin{itemize}
\item Nemerle takes care of hygiene with a coloring algorithm of impressive simplicity and power
\item No complex translation algorithms are necessary
\item As another bonus programmer can fine-tune colors with \texttt{MacroColors}
\item Referential transparency works as well
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Racket}
A Lisp, descendent from Scheme

25 years of hygienic macros, a bunch of macro systems

Language features written using macros (classes, modules, etc)

Q: "How to turn macros into proper abstractions?"
\end{frame}

\begin{frame}[fragile]
\frametitle{Racket}
\begin{semiverbatim}
\visible<2->{\text{\color<3->{blue}{(aif (calculate)}}}
  \visible<2->{\text{\color<3->{blue}{(print it)}}}
  \visible<2->{\text{\color<3->{blue}{(error "does not compute"))}}}

(define-syntax (aif stx)
  (syntax-case stx ()
    ((aif cond then else)
     \visible<4->{(with-syntax ((\text{\color<4->{blue}{it}} (datum->syntax \text{\color<4->{blue}{#'aif}} \text{\color<4->{red}{'it}})))}
       #'(let ((temp cond)
               (\text{\color<4->{blue}{\color<3>{red}{it}}} temp)))
           (if temp then else)))))\visible<4->{)}

\visible<3->{(let* ((temp (calculate))}
       \visible<3->{(\text{\color<4->{blue}{\color<3>{red}{it}}} temp))}
  \visible<3->{(if temp}
    \visible<3->{\text{\color<3->{blue}{(print it)}}}
    \visible<3->{\text{\color<3->{blue}{(error "does not compute")}}))}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Doesn't scale}
\begin{semiverbatim}
\visible<2->{\text{\color<5->{teal}{(aunless (not (calculate))}}}
  \visible<2->{\text{\color<5->{teal}{(print it)}}}
  \visible<2->{\text{\color<5->{teal}{(error "does not compute"))}}}

(define-syntax (aunless stx)
  (syntax-case stx ()
    ((aunless cond then else)
     \text{\color<4->{blue}{#'(aif (not cond) then else)}})))

\visible<3->{\text{\color<4->{red}{(let* ((temp (not (not (calculate))))}}}
       \visible<3->{\text{\color<4->{red}{(}}\text{\color<4->{blue}{it}} \text{\color<4->{red}{temp))}}}
  \visible<3->{\text{\color<4->{red}{(if temp}}}
    \visible<3->{\text{\color<5->{teal}{(print it)}}}
    \visible<3->{\text{\color<5->{teal}{(error "does not compute")}}))}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Solution: dynamic variables}
\begin{semiverbatim}

\visible<2->{\alert<2>{(define-syntax-parameter it (syntax-rules ()))}}

(define-syntax (aif stx)
  (syntax-case stx ()
    ((aif cond then else)
       #'(let ((temp cond)\visible<2>{)}
           \only<1>{    (it temp))}\only<2->{\alert<2>{(syntax-parameterize}
           \visible<2->{\alert<2>{((it (syntax-rules () ((_) temp))))}}}
           \only<2>{  }(if temp then else)))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: overall}
\begin{itemize}
\item There are algorithms that take care of hygiene and referential transparency
\item These algorithms can work in automatic mode, but are flexible enough to give the programmer full control
\item Like a silver bullet
\item Nevertheless sometimes even better solutions come from integration with language features
\end{itemize}
\end{frame}

\section{The vision of the days to come}

\begin{frame}[fragile]
\frametitle{scalamacros.org}
\begin{itemize}
\item Since this semester Scala has macros
\item Even better: macros are an official part of the language in the next production release 2.10.0
\item Now it's time to put the pens down and think about the future
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implicits}
\begin{semiverbatim}
\visible<2->{trait Serializer[T] \{
  def write(pickle: Pickle, x: T): Unit
\}
}
def serialize[T](x: T)\only<2->{(\only<3->{\alert<3-4>{implicit }}s: Serializer[T])}: Pickle

\visible<4->{\only<1-4>{\alert<4>{implicit object ByteSerializer extends Serializer[Byte] \{
  def write(pickle: Pickle, x: Byte) = pickle.writeByte(x)
\}}}\only<5->{\visible<5->{\alert<5>{implicit def generator: Serializer[T] = macro impl[T]

}}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Research proposal}
\begin{itemize}
\item Macros + functions = programmable inlining, specialization, fusion
\item Macros + annotations = code contracts
\item Macros + path-dependent types = controlled effects
\item Macros + implicits = theorem prover
\item ...
\end{itemize}
\end{frame}

\end{document}