\documentclass[hyperref={bookmarks=false}]{beamer}
\useoutertheme{infolines}
\setbeamertemplate{headline}{} % removes the headline that infolines inserts
% \setbeamertemplate{footline}{
%   \hfill%
%   \usebeamercolor[fg]{page number in head/foot}%
%   \usebeamerfont{page number in head/foot}%
%   \insertpagenumber\,/\,\insertpresentationendpage\kern1em\vskip2pt%
% }
\setbeamertemplate{footline}{
  \hfill%
  \usebeamercolor[fg]{page number in head/foot}%
  \usebeamerfont{page number in head/foot}%
  \insertpagenumber\kern1em\vskip2pt%
}
\setbeamertemplate{navigation symbols}{}
\setbeamercolor{alerted text}{fg=blue}
\setbeamerfont{alerted text}{series=\bfseries,family=\ttfamily}
\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}
\usepackage[parfill]{parskip}
\usepackage{color}
\usepackage[linewidth=0.5pt]{mdframed}
\newmdenv[innerleftmargin=1mm, innerrightmargin=1mm, innertopmargin=-1mm, innerbottommargin=2mm, leftmargin=-1mm, rightmargin=-1mm]{lstlistinglike}
\usepackage{tikz}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{textcomp}

\hypersetup{pdfauthor={Eugene Burmako},pdfsubject={Metaprogramming with Macros},pdftitle={Metaprogramming with Macros}}
\title{Scala Macros}

\begin{document}

\title{Metaprogramming with Macros}
\author{Eugene Burmako}
\institute{\'Ecole Polytechnique F\'ed\'erale de Lausanne \\
           \texttt{http://scalamacros.org/}}
\date{10 September 2012}
{
\setbeamertemplate{footline}{}
\begin{frame}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
\frametitle{Macros}
\pause
Macros realize the notion of textual abstraction.

Textual abstraction:
\begin{itemize}
\item Recognize pieces of text that match a specification
\item Replace them according to a procedure
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Why macros?}
\begin{itemize}
\item Deeply embedded DSLs (database access, testing)
\item Optimization (programmable inlining, fusion)
\item Analysis (integrated proof-checker)
\item Effects (effect containment and propagation)
\item ...
\end{itemize}
\end{frame}

% \begin{frame}[fragile]
% \frametitle{Alexandre Dumas}

% \begin{center}
% \includegraphics[width=5.5cm]{dumas}
% \end{center}
% \end{frame}

\section{The prelude of macros}

\begin{frame}[fragile]
\frametitle<1>{\texttt{if} in Lisp}
\frametitle<2>{Anaphoric \texttt{if}}
\frametitle<3>{The \texttt{aif} macro}
\frametitle<4>{Low-level implementation}
\frametitle<5>{Quasiquoting: static template}
\frametitle<6>{Quasiquoting: dynamic holes}
\begin{semiverbatim}
(\only<2->{a}if (calculate)
  (print \only<1>{"success"}\only<2->{it})
  (error "does not compute"))

\visible<3->{(defmacro aif args}
  \visible<4->{\only<4>{\alert{(list '}let* \alert{(list (list '}temp  (car args))}}\only<5->{\alert{`}(let* ((temp \only<5>{...........}\only<6->{\alert{,(car args)}})}}
          \visible<4->{\only<4>{\alert{                  (list '}it \alert{'}temp\alert{))}}\only<5>{(it temp))}}
     \visible<4->{\only<4>{\alert{(list '}if \alert{'}temp}\only<5>{(if temp}}
       \visible<4->{\only<4>{(cadr args)}\only<5>{............}\only<6->{\alert{,(cadr args)}}}
       \visible<4->{\only<4>{(caddr args)\alert{))}}\only<5>{............}\only<6->{\alert{,(caddr args)}})))}

\visible<2->{(let* ((temp (calculate))}
       \visible<2->{(it temp))}
  \visible<2->{(if temp}
    \visible<2->{(print it)}
    \visible<2->{(error "does not compute")))}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Macro by example (MBE)}
\begin{semiverbatim}
(aif (calculate)
  (print it)
  (error "does not compute"))

(defmacro+ aif
  \alert{(aif cond then else)}
  (let* ((temp \alert{cond})
         (it temp))
    (if temp
        \alert{then}
        \alert{else})))

(let* ((temp (calculate))
       (it temp))
  (if temp
    (print it)
    (error "does not compute")))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interlude}
\begin{itemize}
\item Macros are regular functions that happen to work with syntax objects
\item Quasiquotes = static templates + dynamic holes
\end{itemize}
\end{frame}

\section{The tale of bindings}

\begin{frame}[fragile]
\frametitle{Anaphoric \texttt{if}}
\begin{semiverbatim}
(defmacro+ aif
  (aif cond then else)
  (let* ((temp cond)
         (it temp))
    (if temp then else)))
\end{semiverbatim}

\begin{itemize}
\item So far macros are simple: define a function, recognize pieces of text and replace them with a template
\item This is so immediately useful, that we could wrap up right now
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{But actually}
The \texttt{aif} macro has two bugs
\end{frame}

\begin{frame}[fragile]
\frametitle{What's wrong?}
\begin{semiverbatim}
\text{\color<2->{blue}{(aif (calculate)}}
  \text{\color<2->{blue}{(print it)}}
  \text{\color<2->{blue}{(error "does not compute"))}}

(defmacro+ aif
  (aif cond then else)
  \text{\color<2->{red}{(let* ((temp cond)}}
         \text{\color<2->{red}{(it temp))}}
    \text{\color<2->{red}{(if temp then else))}})

\visible<3->{\text{\color<3->{red}{(let* ((temp \text{\color<3->{blue}{(calculate)}})}}}
       \visible<3->{\text{\color<3->{red}{(it temp))}}}
  \visible<3->{\text{\color<3->{red}{(if temp}}}
    \visible<3->{\text{\color<3->{blue}{(print it)}}}
    \visible<3->{\text{\color<3->{blue}{(error "does not compute")}}\text{\color<3->{red}{))}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Bug \#1: Violation of hygiene}
\begin{semiverbatim}
(let ((\text{\color{blue}{temp}} 451{\textdegree}F))
  (aif (calculate)
    (print it)
    (print \text{\color{blue}{temp}})))

(defmacro+ aif
  (aif cond then else)
  (let* ((\text{\color{red}{temp}} cond)
         (it temp))
    (if temp then \text{\color{red}{else}})))

(let ((\text{\color{blue}{temp}} 451{\textdegree}F))
  (let* ((\text{\color{red}{temp}} (calculate))
         (it temp))
    (if temp
      (print it)
      (print \text{\color{red}{temp}}))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Bug \#2: Violation of referential transparency}
\begin{semiverbatim}
(let ((\text{\color{blue}{if}} hijacked))
  (aif (calculate)
    (print it)
    (error "does not compute")))

(defmacro+ aif
  (aif cond then else)
  (let* ((temp cond)
         (it temp))
    (\text{\color{red}{if}} temp then else)))

(let ((\text{\color{blue}{if}} hijacked))
  (let* ((temp (calculate))
         (it temp))
    (\text{\color{blue}{if}} temp
      (print it)
      (error "does not compute"))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Interlude}
\begin{itemize}
\item Cross-pollination of scopes can lead to inadvertent variable capture
\item Violation of hygiene = def site harms call site
\item Violation of referential transparency = call site harms def site
\end{itemize}
\end{frame}

\section{The trilogy of tongues}

\begin{frame}[fragile]
\frametitle{Template Haskell}
\begin{semiverbatim}
{\textdollar}(aif [| calculate |]
  [| putStrLn (show \text{\color<2->{blue}{it}}) |]
  [| error "does not compute" |])

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond then' else' =
  [| let temp = {\textdollar}cond
         \text{\color<2->{red}{it}} = temp
     in if temp /= 0 then {\textdollar}then' else {\textdollar}else' |]

\visible<2->{let temp_a1mx = calculate}
    \visible<2->{\text{\color{red}{it_a1my}} = temp_a1mx}
\visible<2->{in if (temp_a1mx /= 0)}
   \visible<2->{then putStrLn (show \text{\color{blue}{it}})}
   \visible<2->{else error "does not compute"}

\visible<2->{\text{\color{red}{Not in scope: `it'}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{The \texttt{Q} monad}
\begin{semiverbatim}
aif cond then' else' =
  [| let \text{\color<2->{blue}{temp = {\textdollar}cond}}
         \text{\color<2->{blue}{it = temp}}
     in if temp \text{\color<2->{red}{/=}} 0 then {\textdollar}then' else {\textdollar}else' |]

\visible<2>{aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp}
\visible<2>{aif cond' then'' else'' =}
    \visible<2>{do \{ \text{\color{blue}{temp <- newName "temp"}}}
       \visible<2>{; \text{\color{blue}{it <- newName "it"}}}
       \visible<2>{; cond <- cond'}
       \visible<2>{; then' <- then''}
       \visible<2>{; else' <- else''}
       \visible<2>{; \text{\color{red}{let notEq = mkNameG_v "ghc-prim" "GHC.Classes" "/="}}}
         \visible<2>{in return}
          \visible<2>{(LetE [ValD (VarP temp) (NormalB cond) [],}
                 \visible<2>{ValD (VarP it) (NormalB (VarE temp)) []]}
                \visible<2>{(CondE (... (VarE notEq) ...) then' else'))}
       \visible<2>{\}}

\end{semiverbatim}
                % (CondE (InfixE (Just (VarE temp)) (VarE notEq) (Just (LitE (IntegerL 0)))) then' else'))
\end{frame}

\begin{frame}[fragile]
\frametitle{Breaking hygiene}
\begin{semiverbatim}
{\textdollar}(aif [| calculate |]
  [| putStrLn (show \alert{{\textdollar}(dyn "it")}) |]
  [| error "does not compute" |])

aif :: Q Exp -> Q Exp -> Q Exp -> Q Exp
aif cond then' else' =
  [| let temp = {\textdollar}cond
         \text{\color{red}{it}} = temp
     in if temp /= 0 then {\textdollar}then' else {\textdollar}else' |]

let temp_a1mx = calculate
    \text{\color{red}{it_a1my}} = temp_a1mx
in if (temp_a1mx /= 0)
   then putStrLn (show \text{\color{blue}{it_a1my}})
   else error "does not compute"
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: Template Haskell}
\begin{itemize}
\item Quasiquotes in Template Haskell are automatically hygienic and referentially transparent
\item That's because they are lifted into the Q monad, which takes care of names (fresh names for locals,
fully qualified names for globals)
\item Sometimes we need to break hygiene
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Nemerle}
\begin{semiverbatim}
aif(calculate,
  WriteLine(\text{\color<2->{blue}{it}}),
  throw Exception("does not compute"))

macro aif(cond, then, else_) \{
  <[
    def temp = {\textdollar}cond;
    def \text{\color<2->{red}{it}} = temp;
    if (temp != 0) {\textdollar}then else {\textdollar}else_
  ]>
\}

\visible<2->{def calculate = 42;}
\visible<2->{def temp_1087 = calculate;}
\visible<2->{def \text{\color{red}{it_1088}} = temp_1087;}
\visible<2->{if (temp_1087 != 0) WriteLine(\text{\color{blue}{it}}) else throw Exception("...")}

\visible<2->{\text{\color{red}{error: unbound name `it'}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle<1>{Coloring algorithm}
\frametitle<2>{Coloring algorithm: normal code gets a vanilla color}
\frametitle<3>{Coloring algorithm: each expansion gets unique colors}
\frametitle<4>{Coloring algorithm: at the end of the day}
\frametitle<5>{Coloring algorithm: inherit use site}
\begin{semiverbatim}
def \text{\color<2-4>{blue}{calculate}} = 42;                 \only<2->{\text{\color{blue}{// vanilla color}}}
aif(\text{\color<2-4>{blue}{calculate}},
  WriteLine(\text{\color<2-4>{blue}{it}}),
  throw Exception("does not compute"))

macro aif(cond, then, else_) \{      \only<3->{\text{\color{red}{// expansion color}}}
  <[
    def \text{\color<3-4>{red}{temp}} = \text{\color<3-4>{blue}{{\textdollar}cond}};
    def \only<1,2>{it}\only<3,4>{\text{\color{red}{it}}}\only<5>{\text{\color{blue}{{\textdollar}("it": usesite)}}} = \text{\color<3-4>{red}{temp}};
    if (\text{\color<3-4>{red}{temp}} != 0) \text{\color<3-4>{blue}{{\textdollar}then}} else \text{\color<3-4>{blue}{{\textdollar}else_}}
  ]>
\}

def \text{\color<4-4>{blue}{calculate}} = 42;                 \only<4->{// bind using colors}
def \text{\color<4-4>{red}{temp}} = \text{\color<4-4>{blue}{calculate}};
def \text{\color<4>{red}{\color<5>{blue}{it}}} = \text{\color<4-4>{red}{temp}};
if (\text{\color<4-4>{red}{temp}} != 0) WriteLine(\text{\color<4->{blue}{it}}) else throw Exception("...")
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: Nemerle}
\begin{itemize}
\item Nemerle takes care of hygiene with a coloring algorithm of impressive simplicity and power
\item No complex translation algorithms are necessary
\item As another bonus programmer can fine-tune colors with \texttt{MacroColors}
\item Referential transparency works as well
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Racket}
A Lisp, descendent from Scheme

25 years of hygienic macros, a bunch of macro systems

Language features written using macros (classes, modules, etc)

Q: "How to turn macros into proper abstractions?"
\end{frame}

\begin{frame}[fragile]
\frametitle{Racket}
\begin{semiverbatim}
\text{\color<2->{blue}{(aif (calculate)}}
  \text{\color<2->{blue}{(print it)}}
  \text{\color<2->{blue}{(error "does not compute"))}}

(define-syntax (aif stx)
  (syntax-case stx ()
    ((aif cond then else)
     \visible<3->{(with-syntax ((\text{\color<3->{blue}{it}} (datum->syntax \text{\color<3->{blue}{#'aif}} \text{\color<3->{red}{'it}})))}
       #'(let ((temp cond)
               (\text{\color<3->{blue}{\color<2>{red}{it}}} temp)))
           (if temp then else)))))\visible<3->{)}

\visible<2->{(let* ((temp (calculate))}
       \visible<2->{(\text{\color<3->{blue}{\color<2>{red}{it}}} temp))}
  \visible<2->{(if temp}
    \visible<2->{\text{\color<2->{blue}{(print it)}}}
    \visible<2->{\text{\color<2->{blue}{(error "does not compute")}}))}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Doesn't scale}
\begin{semiverbatim}
\text{\color<3->{teal}{(aunless (not (calculate))}}
  \text{\color<3->{teal}{(print it)}}
  \text{\color<3->{teal}{(error "does not compute"))}}

(define-syntax (aunless stx)
  (syntax-case stx ()
    ((aunless cond then else)
     \text{\color<2->{blue}{#'(aif (not cond) then else)}})))

\text{\color<2->{red}{(let* ((temp (not (not (calculate))))}}
       \text{\color<2->{red}{(}}\text{\color<2->{blue}{it}} \text{\color<2->{red}{temp))}}
  \text{\color<2->{red}{(if temp}}
    \text{\color<3->{teal}{(print it)}}
    \text{\color<3->{teal}{(error "does not compute")}}))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Solution: dynamic variables}
\begin{semiverbatim}

\alert{(define-syntax-parameter it (syntax-rules ()))}

(define-syntax (aif stx)
  (syntax-case stx ()
    ((aif cond then else)
     #'(let ((temp cond))
         \alert{(syntax-parameterize}
         \alert{((it (syntax-rules () ((_) temp))))}
           (if temp then else))))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Summary: overall}
\begin{itemize}
\item There are algorithms that take care of hygiene and referential transparency
\item These algorithms can work in automatic mode, but are flexible enough to give the programmer full control
\item Like a silver bullet
\item Nevertheless sometimes even better solutions come from integration with language features
\end{itemize}
\end{frame}

\section{The vision of the days to come}

\begin{frame}[fragile]
\frametitle{scalamacros.org}
\begin{itemize}
\item Since this semester Scala has macros
\item Even better: macros are an official part of the language in the next production release 2.10.0
\item Now it's time to put the pens down and think about the future
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implicits}
\begin{semiverbatim}
\visible<2->{trait Serializer[T] \{
  def write(pickle: Pickle, x: T): Unit
\}
}
def serialize[T](x: T)\only<2->{(\only<3->{\alert<3>{implicit }}s: Serializer[T])}: Pickle

\visible<3->{\only<1-3>{\alert<3>{implicit object ByteSerializer extends Serializer[Byte] \{
  def write(pickle: Pickle, x: Byte) = pickle.writeByte(x)
\}}}\only<4->{\visible<4->{\alert<4>{implicit def generator: Serializer[T] = macro impl[T]

}}}}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Research proposal}

Marry macros and high-level language features:

\begin{itemize}
\item Macros + functions = programmable inlining, specialization, fusion
\item Macros + annotations = code contracts
\item Macros + path-dependent types = controlled effects
\item Macros + implicits = static verification
\item ...
\end{itemize}
\end{frame}

\end{document}