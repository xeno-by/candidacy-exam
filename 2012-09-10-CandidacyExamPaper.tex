\documentclass[10pt,journal,a4paper]{IEEEtran}

\usepackage{lipsum}
\usepackage{array}
\usepackage{mdframed}
\newmdenv[linewidth=0.5pt, innerleftmargin=1mm, innerrightmargin=1mm, innertopmargin=1mm, innerbottommargin=1mm, leftmargin=0mm, rightmargin=0mm]{listing}
\usepackage{changepage}

\newcommand\MYhyperrefoptions{bookmarks=true,bookmarksnumbered=true,
pdfpagemode={UseOutlines},plainpages=false,pdfpagelabels=true,
colorlinks=true,linkcolor={black},citecolor={black},pagecolor={black},
urlcolor={black},
pdftitle={Metaprogramming with Macros},
pdfsubject={Metaprogramming with Macros},
pdfauthor={Eugene Burmako},
pdfkeywords={metaprogramming, macros, quasiquotes, hygiene, referential transparency}}

\begin{document}

\title{Metaprogramming with Macros}

\author{Eugene Burmako% <-this % stops a space
\\ \hskip90pt LAMP, I\&C,  EPFL % no idea why I need an hskip, but I'm not a latex whiz
\thanks{\normalsize Proposal submitted to committee: September 3rd, 2012; Candidacy exam date: September 10th, 2012; Candidacy exam committee: Christoph Koch, Martin Odersky, Viktor Kuncak.}%
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem }
\thanks{\large This research plan has been approved:}%
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large Date:\hfill------------------------------------}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large Doctoral candidate:\hfill------------------------------------}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \footnotesize \hfill                      (name and signature)\hspace{1.5cm}\hfill}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large Thesis director:\hfill------------------------------------}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \footnotesize \hfill                      (name and signature)\hspace{1.5cm}\hfill}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large Thesis co-director:\hfill------------------------------------}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \footnotesize (if applicable)\hfill  (name and signature)\hspace{1.5cm}\hfill}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large Doct. prog. director:\hfill------------------------------------}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \footnotesize (R. Urbanke)  \hfill                    (signature)\hspace{1.5cm}\hfill}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \large}
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem \tiny EDIC-ru/05.05.2009}
}

\markboth{EDIC Research Proposal}%
{Shell \MakeLowercase{\textit{et al.}}: EDIC Research Proposal}

\IEEEcompsoctitleabstractindextext{%
\begin{abstract}
Macros realize the notion of textual abstraction.
Textual abstraction consists of recognizing pieces of text
that match a specification and replacing them according
to a procedure.

In the focus of the study are syntactic macros in lexically
scoped programming languages. We identify the problems
of \emph{hygiene} and \emph{referential transparency}
and describe the solutions employed in Template Haskell \cite{sheard02},
Nemerle \cite{skalski04} and Racket \cite{barzilay11}.

We discuss integration of hygienic macros into statically typed languages
and propose to improve upon state of the art by providing
a type system for syntax templates and uncovering synergies with
high-level language features such as path-dependent types and implicits \cite{odersky10}.
\end{abstract}

\begin{IEEEkeywords}
metaprogramming, macros, quasiquotes, hygiene, referential transparency
\end{IEEEkeywords}}

\maketitle
\IEEEdisplaynotcompsoctitleabstractindextext
\IEEEpeerreviewmaketitle

\section{Introduction}

% \subsection{Procedural abstraction}

\IEEEPARstart{P}{rocedural} abstraction is pervasive.
Factoring out parameterized fragments of programs into procedures
is a conventional best practice.

Modern programming languages integrate the notion of procedures into their semantics.
Procedures are viewed as independent programs that can communicate with the main program.
As of such they can be manipulated as units, and big procedures can be built from the smaller ones.
This is a powerful way to manage complexity of software systems.

However procedural abstraction is sometimes not enough, because
its manifestations are bound by language syntax and it operates within the semantics
of the language.

For example, in most programming languages it is impossible to define short-circuiting logical operators
as procedures, because procedures are usually not in control of operational semantics.
Another example in this vein is a C-like \texttt{for} loop, which supports
optional prologue that introduces variables visible in its body. Procedures typically cannot abstract
over variable bindings, so they cannot express this language construct.

% \subsection{Textual abstraction}

\emph{Textual abstraction} consists of recognizing pieces of text
that match a specification and replacing them according
to a procedure.
Matched fragments are referred to as macro calls or macro applications, and
procedures that transform them are dubbed macros or macro transformers.
The process of applying macros is called macro expansion \cite{kohlbecker86}.

Having means of textual abstraction in their toolbox, programmers can use a multitude of techniques,
some of which are:
\begin{itemize}
\item reification (providing programs with ways to treat code as data),
\item language virtualization (overloading/overriding semantics of the original programming language
to enable deep embedding of DSLs),
\item programmable optimization (application of optimizations such as inlining
or fusion based on knowledge about the program being optimized),
\item static verification (using reified representation of the program
and, possibly, its contracts defined alongside the program, to verify invariants
at compile time),
\item algorithmic program construction (generation of code that is tedious to write with
the abstractions supported by a programming language).
\end{itemize}

One possibility to implement a macro system is having it as a standalone tool
operating on character streams. This gives rise to lexical macros.
Such a design warrants simplicity of the implementation,
but undermines robustness, because macros operating on lexical level
have no mechanism that prevents generation of syntactically invalid programs.

Another approach would be to integrate a macro expander into the compiler and
have macros work with syntax trees, introducing \emph{syntactic macros}.
In this model macro application is a node in the program tree,
and macro expansion produces a new node that replaces the macro application
without distorting the structure of the program.

Problems inherent to syntactic macros can be divided into two categories:
inadvertent variable capture and semantically invalid expansions.
The rest of the papers dwells upon these challenges.

\begin{figure*}
\begin{listing}
\normalsize

\begin{tabular}{p{4.0cm} p{15cm}}\\
 &
\begin{verbatim}
(let ((x 40) (y 2)) (print (+ x y)))

((lambda (x y) (print (+ x y))) (40 2))
\end{verbatim}
\end{tabular}

\begin{center}
a) Examples of a macro application and a macro expansion of the \texttt{let} macro
\end{center}

\begin{tabular}{p{8.5cm} p{8.5cm}}\\
\begin{verbatim}
(defmacro let args
  (cons
    (cons 'lambda
          (cons (map car (car args))
                (cdr args)))
    (map cadr (car args))))
\end{verbatim}
&
\begin{verbatim}
(defmacro let (decls body)
 `(
    (lambda
      ,(map car decls)
      ,body)
    ,@(map cadr decls)))
\end{verbatim}\\
b) Creates the result at low level (manipulates S-expressions
with standard symbol and list processing functions)
&
c) Uses quasiquotes \cite{bawden99} as a templating mechanism
(backquote introduces a static code template, commas splice dynamic values
into the template)
\end{tabular}

\begin{tabular}{p{3.5cm} p{13.5cm}}\\
 &
\begin{verbatim}
(define-syntax let
  (syntax-rules ()
    ((let ((name expr) ...) body ...)
    ((lambda (name ...) body ...) expr ...))))
\end{verbatim}
\end{tabular}

\begin{adjustwidth}{4cm}{0pt}
d) Macro-by-example notation \cite{kohlbecker87} (uses a tree matching macro that\\
can extract and reassemble fragments of syntax objects; ellipses cap-\\ture
recurrent parts of the input)
\end{adjustwidth}

\begin{tabular}{p{2.5cm} p{14.5cm}}\\
 &
\begin{verbatim}
(define-syntax (let stx)
  (syntax-parse stx
    ((let ((name:identifier expr:expr) ...) body:expr ...)
     #:fail-when (check-duplicate #'(var ...))
                  "duplicate variable name"
     #'((lambda (name ...) body ...) expr ...))))
\end{verbatim}
\end{tabular}

\begin{adjustwidth}{3.2cm}{0pt}
e) Macro-by-example notation augmented with a syntax specification \cite{culpepper10}
(colons \\denote syntax classes, which are first-class and can be built from the ground up).
\end{adjustwidth}
\end{listing}
\end{figure*}

\begin{figure*}
\hskip3.95cm
\normalsize Figure 1. Assorted implementations of the \texttt{let} macro in Lisp dialects
% saves an empty line
% \begin{center}
% \normalsize Figure 1. Assorted implementations of the \texttt{let} macro in Lisp dialects
% \end{center}
\end{figure*}

\section{Examples}

\texttt{let} is a language construct typical to functional languages, which introduces
a scope for a computation and brings temporary variables with provided values into that scope.
To implement \texttt{let} the compiler might wrap the computation in a lambda abstraction
and apply it right away (Figure 1a).

This notion cannot be abstracted procedurally, because the body of the computation typically
contains free variables. However textual abstraction fits the bill, because macros can manipulate
the program on a level, where bindings don't exist and therefore don't impose restrictions.
To set up a stage for further discussion, let's implement the \texttt{let} macro in Lisp.

The most straightforward solution to the problem is a low-level macro transformer (Figure 1b).
It takes an S-expression that represents a macro application, destructures it using standard
list manipulation functions, such as \texttt{car} and \texttt{cdr}, and creates a new S-expression
with \texttt{cons}. Even in this simple example this notation is very noisy. It's quite difficult
to figure out expected shapes of input and output expressions from the imperative algorithm.

Quasiquotes \cite{bawden99} make it possible to reduce obscurity of the macro by providing
a domain-specific language for syntax templates (Figure 1c). The quasiquote operator (\texttt{`})
demarcates a static template. Quasiquoted code is inserted verbatim into the output
(that's why there's no longer need in explicit \texttt{cons}'ing). Unquote operators (\texttt{,}
and \texttt{,@}) interrupt a quasiquote, producing "holes" filled in with dynamically calculated
data. For example, for \texttt{let} we statically know the shape of code to produce (an application
of a lambda abstraction) - this makes up the static part of the quasiquote. On the other hand,
body and parameters of the lambda as well as the arguments of the application may vary from
expansion to expansion - this is the dynamic part.

\begin{thebibliography}{1}

\bibitem{sheard02}
T.~Sheard and S.~Peyton Jones,
Template meta-programming for Haskell.
ACM SIGPLAN Notices, 2002.

\bibitem{skalski04}
K.~Skalski, M.~Moskal and P.~Olszta,
Meta-programming in Nemerle.
Generative Programming and Component Engineering, 2004.

\bibitem{barzilay11}
E.~Barzilay, R.~Culpepper and M.~Flatt,
Keeping it Clean with Syntax Parameters.
Scheme and Functional Programming Workshop, 2011.

\bibitem{odersky10}
M.~Odersky, L.~Spoon and B.~Venners,
Programming in Scala 2nd Edition.
Artima, 2010.

\bibitem{kohlbecker86}
E.~Kohlbecker,
Syntactic Extensions in the Programming Language Lisp.
PhD thesis, Indiana University, 1986.

\bibitem{bawden99}
A.~Bawden,
Quasiquotation in Lisp,
Partial Evaluation and SemanticBased Program Manipulation, 1999.

\bibitem{kohlbecker87}
E.~Kohlbecker, M.~Wand,
Macro-by-Example: Deriving Syntactic Transformations from their Specifications,
Principles of Programming Languages, 1987.

\bibitem{culpepper10}
R.~Culpepper, M.~Felleisen,
Fortifying Macros,
International Conference on Functional Programming, 2010.

\end{thebibliography}

\end{document}
